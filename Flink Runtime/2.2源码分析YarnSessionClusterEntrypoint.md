## 

## YarnSessionClusterEntrypoint

YarnSessionClusterEntrypoint解读一下它的类结构：

```
主要字段：
	/** The lock to guard startup / shutdown / manipulation methods. */
	private final Object lock = new Object();

	private final Configuration configuration;

	private final CompletableFuture<Void> terminationFuture;

	private final AtomicBoolean isTerminating = new AtomicBoolean(false);

	private final AtomicBoolean isShutDown = new AtomicBoolean(false);

	@GuardedBy("lock")
	private MetricRegistryImpl metricRegistry;

	@GuardedBy("lock")
	private HighAvailabilityServices haServices;

	@GuardedBy("lock")
	private BlobServer blobServer;

	@GuardedBy("lock")
	private HeartbeatServices heartbeatServices;

	@GuardedBy("lock")
	private RpcService commonRpcService;

	@GuardedBy("lock")
	private ResourceManager<?> resourceManager;

	@GuardedBy("lock")
	private Dispatcher dispatcher;

	@GuardedBy("lock")
	private LeaderRetrievalService dispatcherLeaderRetrievalService;

	@GuardedBy("lock")
	private LeaderRetrievalService resourceManagerRetrievalService;

	@GuardedBy("lock")
	private WebMonitorEndpoint<?> webMonitorEndpoint;

	@GuardedBy("lock")
	private ArchivedExecutionGraphStore archivedExecutionGraphStore;

	@GuardedBy("lock")
	private TransientBlobCache transientBlobCache;

	@GuardedBy("lock")
	private ClusterInformation clusterInformation;

	@GuardedBy("lock")
	private JobManagerMetricGroup jobManagerMetricGroup;

	private final Thread shutDownHook;

	private final String workingDirectory;
	
主要方法：
protected void startCluster()

```

## YarnSessionClusterEntrypoint（master）启动日志

YarnSessionClusterEntrypoint.main做了哪些事情？

(ClusterEntrypoint.java:182:startCluster) - Starting YarnSessionClusterEntrypoint.

​       (ClusterEntrypoint.java:206:configureFileSystems) - Install default filesystem.

​	runCluster

## YarnSessionClusterEntrypoint.startCluster

ClusterEntrypoint.startCluster  -> runCluster

​	ClusterEntrypoint.initializeServices

​	ClusterEntrypoint.startClusterComponents

```java
# ClusterEntrypoint.runCluster
	protected void runCluster(Configuration configuration) throws Exception {
		synchronized (lock) {  
			initializeServices(configuration);

			// write host information into configuration
			configuration.setString(JobManagerOptions.ADDRESS, commonRpcService.getAddress());
			configuration.setInteger(JobManagerOptions.PORT, commonRpcService.getPort());

			startClusterComponents(
				configuration,
				commonRpcService,
				haServices,
				blobServer,
				heartbeatServices,
				metricRegistry);

			dispatcher.getTerminationFuture().whenComplete(
				(Void value, Throwable throwable) -> {
					if (throwable != null) {
						LOG.info("Could not properly terminate the Dispatcher.", throwable);
					}

					// This is the general shutdown path. If a separate more specific shutdown was
					// already triggered, this will do nothing
					shutDownAndTerminate(
						SUCCESS_RETURN_CODE,
						ApplicationStatus.SUCCEEDED,
						throwable != null ? throwable.getMessage() : null,
						true);
				});
		}
	}
```



## YarnSessionClusterEntrypoint.initializeServices



1. create an AkkaRpcService `commonRpcService = createRpcService(configuration, bindAddress, portRange);`
2. update jobmanager.rpc.address|port use commonRpcService in flink configuration.

1. haServices = createHaServices(configuration, commonRpcService.getExecutor())
2. blobServer = new BlobServer(configuration, haServices.createBlobStore());
3. heartbeatServices = createHeartbeatServices(configuration);
4. metricRegistry = createMetricRegistry(configuration)
5. MetricQueryService, metricRegistry.startQueryService(actorSystem, null); 
6. archivedExecutionGraphStore = createSerializableExecutionGraphStore(configuration, commonRpcService.getScheduledExecutor())
7. clusterInformation = new ClusterInformation(
   commonRpcService.getAddress(),
   			blobServer.getPort());
8. transientBlobCache = new TransientBlobCache(configuration,new InetSocketAddress(clusterInformation.getBlobServerHostname(),clusterInformation.getBlobServerPort()));



## ClusterEntrypoint.startClusterComponents

ClusterEntrypoint.startClusterComponents(configuration,commonRpcService,haServices,blobServer,heartbeatServices,metricRegistry)



1. dispatcherLeaderRetrievalService = highAvailabilityServices.getDispatcherLeaderRetriever()

1. resourceManagerRetrievalService = highAvailabilityServices.getResourceManagerLeaderRetriever()
2. LeaderGatewayRetriever<DispatcherGateway> dispatcherGatewayRetriever = new RpcGatewayRetriever
3. LeaderGatewayRetriever<ResourceManagerGateway> resourceManagerGatewayRetriever = new RpcGatewayRetriever
4. WebMonitorEndpoint webMonitorEndpoint = createRestEndpoint(
   configuration,
   		dispatcherGatewayRetriever,
   		resourceManagerGatewayRetriever,
   		transientBlobCache,
   		rpcService.getExecutor(),
   		new AkkaQueryServiceRetriever(actorSystem, timeout),highAvailabilityServices.getWebMonitorLeaderElectionService()) `webMonitorEndpoint  : Rest endpoint which serves the web frontend REST calls`
5. YarnResourceManager resourceManager = createResourceManager(
   configuration,
   		ResourceID.generate(),
   		rpcService,
   		highAvailabilityServices,
   		heartbeatServices,
   		metricRegistry,
   		this,
   		clusterInformation,
   		webMonitorEndpoint.getRestBaseUrl())  
    `ResourceManager implementation. The resource manager is responsible for resource de-/allocation and bookkeeping.  
   It offers the following methods as part of its rpc interface to interact with him remotely: {@link #registerJobManager(JobMasterId, ResourceID, String, JobID, Time)} registers a {@link JobMaster} at the resource manager {@link #requestSlot(JobMasterId, SlotRequest, Time)} requests a slot from the resource manager`
6. jobManagerMetricGroup = MetricUtils.instantiateJobManagerMetricGroup(metricRegistry, rpcService.getAddress())
7. dispatcher = createDispatcher(
   configuration,
   		rpcService,
   		highAvailabilityServices,
   resourceManager.getSelfGateway(ResourceManagerGateway.class),
   		blobServer,
   		heartbeatServices,
   		jobManagerMetricGroup,
   		metricRegistry.getMetricQueryServicePath(),
   		archivedExecutionGraphStore,
   		this,
   		webMonitorEndpoint.getRestBaseUrl())

LOG.debug("Starting ResourceManager.");
resourceManager.start();
resourceManagerRetrievalService.start(resourceManagerGatewayRetriever);

LOG.debug("Starting Dispatcher.");
dispatcher.start();
dispatcherLeaderRetrievalService.start(dispatcherGatewayRetriever);

## YarnSessionClusterEntrypoint中重要的services

### RpcService commonRpcService

它是一个Actor, jobmanager的地址，起taskmanager的时候，flinkconf.yaml里面的参数jobmanager.rpc.address|port,

就是它的地址.

### HighAvailabilityServices haServices

org.apache.flink.runtime.highavailability.zookeeper.HighAvailabilityServices

对那些内容作了高可靠？

 * The HighAvailabilityServices give access to all services needed for a highly-available
 * setup. In particular, the services provide access to highly available storage and
 * registries, as well as distributed counters and leader election.
 * <ul>
 * <li>ResourceManager leader election and leader retrieval</li>
 * <li>JobManager leader election and leader retrieval</li>
 * <li>Persistence for checkpoint metadata</li>
 * <li>Registering the latest completed checkpoint(s)</li>
 * <li>Persistence for the BLOB store</li>
 * <li>Registry that marks a job's status</li>
 * <li>Naming of RPC endpoints</li>
 * </ul>



————— initializeServices

### BlobServer blobServer

This class implements the BLOB server. The BLOB server is responsible for listening for incoming requests and spawning threads to handle these requests. Furthermore, it takes care of creating the directory structure to store the BLOBs or temporarily cache them.

BlobServer解读：<http://chenyuzhao.me/2017/02/08/jobmanager%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/>



### HeartbeatServices heartbeatServices;

HeartbeatServices gives access to all services needed for heartbeating. This includes the creation of heartbeat receivers and heartbeat senders.

heartbeatInterval , heartbeatTimeout



### MetricRegistryImpl metricRegistry;

org.apache.flink.runtime.metrics.MetricRegistryImpl

在commonRpcService里面起了一个Actor作为MetricQueryService服务



### ArchivedExecutionGraphStore archivedExecutionGraphStore;

存储ExecutionGraph，目前是放在内存里面。

### ClusterInformation clusterInformation;

ClusterInformation(commonRpcService.getAddress(),blobServer.getPort());



### TransientBlobCache transientBlobCache;

 Provides access to transient BLOB files stored at the {@link BlobServer}.



-----------------startClusterComponents

### WebMonitorEndpoint<?> webMonitorEndpoint;

Rest endpoint which serves the web frontend REST calls.

Dispatcher REST endpoint



### ResourceManager<?> resourceManager;

org.apache.flink.yarn.YarnResourceManager

The yarn implementation of the resource manager. Used when the system is started via the resource framework YARN.



### JobManagerMetricGroup jobManagerMetricGroup;

jobManager节点metric注册模块



### Dispatcher dispatcher;

Base class for the Dispatcher component. The Dispatcher component is responsible for receiving job submissions, persisting them, spawning JobManagers to execute the jobs and to recover them in case of a master failure. Furthermore, it knows about the state of the Flink session cluster.

org.apache.flink.runtime.dispatcher.StandaloneDispatcher

Dispatcher implementation which spawns a {@link JobMaster} for each submitted {@link JobGraph} within in the same process. This dispatcher can be used as the default for all different session clusters.

```
	private final Configuration configuration;

	private final SubmittedJobGraphStore submittedJobGraphStore;
	private final RunningJobsRegistry runningJobsRegistry;

	private final HighAvailabilityServices highAvailabilityServices;
	private final ResourceManagerGateway resourceManagerGateway;
	private final JobManagerSharedServices jobManagerSharedServices;
	private final HeartbeatServices heartbeatServices;
	private final BlobServer blobServer;

	private final FatalErrorHandler fatalErrorHandler;

	private final Map<JobID, JobManagerRunner> jobManagerRunners;

	private final LeaderElectionService leaderElectionService;

	private final ArchivedExecutionGraphStore archivedExecutionGraphStore;

	private final JobManagerRunnerFactory jobManagerRunnerFactory;

	private final JobManagerMetricGroup jobManagerMetricGroup;

	private final HistoryServerArchivist historyServerArchivist;

	@Nullable
	private final String metricQueryServicePath;

	@Nullable
	protected final String restAddress;

	private final Map<JobID, CompletableFuture<Void>> jobManagerTerminationFutures;
```



### LeaderRetrievalService dispatcherLeaderRetrievalService;

从zk上取回，dispatcher的leader节点

ZooKeeperLeaderRetrievalService重点看一下这个类。

### LeaderRetrievalService resourceManagerRetrievalService;

从zk上取回，resourcemanager的leader节点



# 参考文献

1. Flink Deployment - YARN SETUP <https://ci.apache.org/projects/flink/flink-docs-release-1.4/ops/deployment/yarn_setup.html>
2. [FLIP-6 - Flink Deployment and Process Model - Standalone, Yarn, Mesos, Kubernetes, etc.](https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=65147077)
3. kerberos认证原理---讲的非常细致，易懂<http://blog.csdn.net/wulantian/article/details/42418231>

