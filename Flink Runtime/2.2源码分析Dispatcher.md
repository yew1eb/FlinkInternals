Base class for the Dispatcher component. The Dispatcher component is responsible for receiving job submissions, persisting them, spawning JobManagers to execute the jobs and to recover them in case of a master failure. Furthermore, it knows about the state of the Flink session cluster.

org.apache.flink.runtime.dispatcher.StandaloneDispatcher

Dispatcher implementation which spawns a {@link JobMaster} for each submitted {@link JobGraph} within in the same process. This dispatcher can be used as the default for all different session clusters.

```
	private final Configuration configuration;

	private final SubmittedJobGraphStore submittedJobGraphStore;
	private final RunningJobsRegistry runningJobsRegistry;

	private final HighAvailabilityServices highAvailabilityServices;
	private final ResourceManagerGateway resourceManagerGateway;
	private final JobManagerSharedServices jobManagerSharedServices;
	private final HeartbeatServices heartbeatServices;
	private final BlobServer blobServer;

	private final FatalErrorHandler fatalErrorHandler;

	private final Map<JobID, JobManagerRunner> jobManagerRunners;

	private final LeaderElectionService leaderElectionService;

	private final ArchivedExecutionGraphStore archivedExecutionGraphStore;

	private final JobManagerRunnerFactory jobManagerRunnerFactory;

	private final JobManagerMetricGroup jobManagerMetricGroup;

	private final HistoryServerArchivist historyServerArchivist;

	@Nullable
	private final String metricQueryServicePath;

	@Nullable
	protected final String restAddress;

	private final Map<JobID, CompletableFuture<Void>> jobManagerTerminationFutures;
```



## Dsipatcher.submitJob流程分析

2018-08-04 19:45:34,903  INFO (Dispatcher.java:238:submitJob) - Submitting job e04493249c72dea9cc5a0ac0c047f9ee (consumekafkawithwindowagg-1.6).
2018-08-04 19:45:34,934  INFO (AkkaRpcService.java:224:startServer) - Starting RPC endpoint for org.apache.flink.runtime.jobmaster.JobMaster at akka://flink/user/jobmanager_0 .

```

	@Override
	public CompletableFuture<Acknowledge> submitJob(JobGraph jobGraph, Time timeout) 
	-->
		private void runJob(JobGraph jobGraph) throws Exception {
		Preconditions.checkState(!jobManagerRunners.containsKey(jobGraph.getJobID()));

		final JobManagerRunner jobManagerRunner = createJobManagerRunner(jobGraph);

		jobManagerRunner.start();

		jobManagerRunners.put(jobGraph.getJobID(), jobManagerRunner);
	}
```

在JobManagerRunner的构造方法里面会创建一个JobMaster的构造方法里面会创建一个

this.executionGraph = createAndRestoreExecutionGraph(jobManagerJobMetricGroup);

 --> createExecutionGraph  

———> ExecutionGraphBuilder.buildGraph(
			null,
			jobGraph,
			jobMasterConfiguration.getConfiguration(),
			scheduledExecutorService,
			scheduledExecutorService,
			slotPool.getSlotProvider(),
			userCodeLoader,
			highAvailabilityServices.getCheckpointRecoveryFactory(),
			rpcTimeout,
			restartStrategy,
			currentJobManagerJobMetricGroup,
			blobServer,
			jobMasterConfiguration.getSlotRequestTimeout(),
			log);



什么时候触发调度？

(JobManagerRunner.java:329:verifyJobSchedulingStatusAndStartJobManager) 

JobMaster.start(final JobMasterId newJobMasterId, final Time timeout)

ExecutionGraph.scheduleForExecution

